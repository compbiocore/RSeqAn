{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RSeqAn SeqAn Headers for R Overview This package provides R with access to SeqAn v2.4 header files. SeqAn is an open source C++ library of efficient algorithms and data structures for the analysis of sequences with the focus on biological data. Usage RSeqAn can be used via the LinkingTo: field in the DESCRIPTION field of an R package. Note that the compiler will need to compile as C++14. This can be done in R as Sys.setenv(\"PKG_CXXFLAGS\"=\"-std=c++14\") . For a quick example, see our introductory vignette . Alternatively you can run the C++ code from the vignette directly by entering Rcpp :: sourceCpp ( system.file ( \"extdata\" , \"first_example.cpp\" , package = \"RSeqAn\" )) pattern_search ( \"This is an awesome tutorial to get to know SeqAn!\" , \"tutorial\" ) Don't forget to set the C++14 compiler flags if you do this! Installation We recommend installing the release version through Bioconductor , especially if you are running R on Windows. Instructions are provided on their page. Version 1.3.1 can also be installed through Bioconductor (for now, Bioconductor has a separate release cycle), downloaded as a tagged release , or installed with devtools by running: devtools :: install_github ( \"compbiocore/RSeqAn\" , ref = \"v1.3.1\" ) This version contains Rcpp::as and Rcpp::wrap functions for CharString and is the one submitted to the Journal of Open Source Software . The development version can be installed with devtools by running: devtools :: install_github ( \"compbiocore/RSeqAn\" , ref = \"devel\" ) This version contains additional wrappers, though we cannot guarantee that they will work for you. Author August Guang Release history See NEWS for release history. Citation If you use this package in your work, even if only in auxiliary tools or pipelines please cite: Guang, (2019). RSeqAn: Headers and wrappers for the SeqAn library in R. Journal of Open Source Software, 4(34), 1160, https://doi.org/10.21105/joss.01160 Please do not forget to cite SeqAn as well: Reinert, K., Dadi, T. H., Ehrhardt, M., Hauswedell, H., Mehringer, S., Rahn, R., \u2026 Weese, D. (2017). The SeqAn C++ template library for efficient sequence analysis: A resource for programmers. Journal of Biotechnology. https://doi.org/10.1016/j.jbiotec.2017.07.017","title":"Home"},{"location":"#rseqan","text":"SeqAn Headers for R","title":"RSeqAn"},{"location":"#overview","text":"This package provides R with access to SeqAn v2.4 header files. SeqAn is an open source C++ library of efficient algorithms and data structures for the analysis of sequences with the focus on biological data.","title":"Overview"},{"location":"#usage","text":"RSeqAn can be used via the LinkingTo: field in the DESCRIPTION field of an R package. Note that the compiler will need to compile as C++14. This can be done in R as Sys.setenv(\"PKG_CXXFLAGS\"=\"-std=c++14\") . For a quick example, see our introductory vignette . Alternatively you can run the C++ code from the vignette directly by entering Rcpp :: sourceCpp ( system.file ( \"extdata\" , \"first_example.cpp\" , package = \"RSeqAn\" )) pattern_search ( \"This is an awesome tutorial to get to know SeqAn!\" , \"tutorial\" ) Don't forget to set the C++14 compiler flags if you do this!","title":"Usage"},{"location":"#installation","text":"We recommend installing the release version through Bioconductor , especially if you are running R on Windows. Instructions are provided on their page. Version 1.3.1 can also be installed through Bioconductor (for now, Bioconductor has a separate release cycle), downloaded as a tagged release , or installed with devtools by running: devtools :: install_github ( \"compbiocore/RSeqAn\" , ref = \"v1.3.1\" ) This version contains Rcpp::as and Rcpp::wrap functions for CharString and is the one submitted to the Journal of Open Source Software . The development version can be installed with devtools by running: devtools :: install_github ( \"compbiocore/RSeqAn\" , ref = \"devel\" ) This version contains additional wrappers, though we cannot guarantee that they will work for you.","title":"Installation"},{"location":"#author","text":"August Guang","title":"Author"},{"location":"#release-history","text":"See NEWS for release history.","title":"Release history"},{"location":"#citation","text":"If you use this package in your work, even if only in auxiliary tools or pipelines please cite: Guang, (2019). RSeqAn: Headers and wrappers for the SeqAn library in R. Journal of Open Source Software, 4(34), 1160, https://doi.org/10.21105/joss.01160 Please do not forget to cite SeqAn as well: Reinert, K., Dadi, T. H., Ehrhardt, M., Hauswedell, H., Mehringer, S., Rahn, R., \u2026 Weese, D. (2017). The SeqAn C++ template library for efficient sequence analysis: A resource for programmers. Journal of Biotechnology. https://doi.org/10.1016/j.jbiotec.2017.07.017","title":"Citation"},{"location":"containment_test/","text":"containment_test : containment test Description containment test Usage containment_test ( s1 ) Arguments Argument Description s1 Should be a character string","title":"`containment_test`: containment test"},{"location":"containment_test/#containment_test-containment-test","text":"","title":"containment_test: containment test"},{"location":"containment_test/#description","text":"containment test","title":"Description"},{"location":"containment_test/#usage","text":"containment_test ( s1 )","title":"Usage"},{"location":"containment_test/#arguments","text":"Argument Description s1 Should be a character string","title":"Arguments"},{"location":"first_example/","text":"Introduction The reason RSeqAn was created was to allow for easy integration of the SeqAn biological sequence analysis C++ library into R packages. While R is an excellent language for many other applications, it is just not fast enough for reading and writing files on the scale of next generation sequencing output. This is where a well-developed and mature library like SeqAn comes in. This vignette only goes through the first example in the A First Example section as found in the Getting Started section of the SeqAn docs. We have modified the function slightly to make it work here in R, and will go through how and why we did so. The purpose of using this example is to help the user get an idea of how to go between SeqAn and R. To take full advantage of SeqAn though the user will need to read through SeqAn's documentation. Besides that, the user is expected to have some experience with both C++ and Rcpp, although it not need be extensive. After all, that is what RSeqAn is for. Template functions and template classes The simple example in pattern_search does, as you might expect, a pattern search of a short query sequence (pattern) in a long subject sequence. It returns an integer score value for each position of the database sequence (text) as the sum of matching characters between the pattern string and the subject substring of the database sequence. // [[Rcpp::depends(RSeqAn)]] #include <iostream> #include <seqan/file.h> #include <seqan/sequence.h> #include <Rcpp.h> using namespace Rcpp ; using namespace seqan ; // [[Rcpp::export]] IntegerVector pattern_search ( std :: string t , std :: string p ) { seqan :: String < char > text = t ; seqan :: String < char > pattern = p ; seqan :: String < int > score ; resize ( score , length ( text ) - length ( pattern ) + 1 ); // Computation of the similarities // Iteration over the text (outer loop) for ( unsigned i = 0 ; i < length ( text ) - length ( pattern ) + 1 ; ++ i ) { int localScore = 0 ; // Iteration over the pattern for character comparison for ( unsigned j = 0 ; j < length ( pattern ); ++ j ) { if ( text [ i + j ] == pattern [ j ]) ++ localScore ; } score [ i ] = localScore ; } // Returning the result IntegerVector s ( length ( score )); for ( unsigned i = 0 ; i < length ( score ); ++ i ) s [ i ] = score [ i ]; return s ; } The results are shown below. We see that the maximum score possible is 8, as there are 8 characters in the pattern tutorial , and it achieves that maximum score when we match together tutorial in the text string and tutorial in the pattern string. As well, the first position has a score of 1, because the i in the pattern string tutorial matches the 1 i in is ; the subject substring here is This is . pattern_search ( \"This is an awesome tutorial to get to know SeqAn!\" , \"tutorial\" ) #> [1] 1 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 0 1 0 8 0 1 0 0 0 0 2 0 1 0 0 1 0 3 0 #> [36] 1 0 1 0 0 0 0 A more detailed look at the program As we can see, writing a C++ function that utilizes SeqAn inside R is quite easy with Rcpp. We included <seqan/file.h> as well as <seqan/sequence.h> as those are the modules that provide the SeqAn String class . This is one of the most fundamental classes in SeqAn. However, the function we wrote does look slightly different from the one in the A First Example section. First, instead of the function int main() , we have instead written the function IntegerVector pattern_search(std::string t, std::string p) . (Note: we already declared the namespace std, but it was left here in the function for clarity) Next, instead of printing the score to stdout, we are returning it as an IntegerVector . The reason we did this is that in order for any function using SeqAn to be useful in R, we probably want it to return something and to take in input. This means that the input and output object types need to be translatable between R and C++. SeqAn uses its own template functions and template classes , and the String class is one of the most fundamental classes in SeqAn. This makes sense since SeqAn is all about analyzing sequences. However, the String class has no direct translation to R. If you try to input String<char> text or return String<int> score you will end up with loads of errors from the compiler. So, how do we deal with this? One way to do this is by writing conversion functions such that R and C++ both understand what the data type you are using (such as String) means. Rcpp provides a nice way to do this through Rcpp::as<T>(obj) to convert from R to C++ and Rcpp::wrap(obj) to convert from C++ to R. More of this is covered in the Rcpp vignette Extending Rcpp . Once these functions are written, this is nice for the user as they can just go ahead and Rcpp::wrap and Rcpp::as<T> as they need. This has not been implemented in RSeqAn yet though, although it is a future goal. Thus for now the user will have to pay attention to how to convert between classes in SeqAn and objects in R for each function that is written. Rcpp has its own data types for going between R and C++, and so that is the IntegerVector we declare here. Since score is essentially a vector of class String with type int , instead of iterating through score and printing to stdout, we create an IntegerVector s with the same length as score and iterate through score copying its values to s in order to be able to return the values in score . Similarly, we make use of the fact that Rcpp already autoconverts character strings in R to character strings in C++ and that character strings in C++ can be converted to String<char> in SeqAn to write pattern_search such that we can run it from R.","title":"Introduction to using RSeqAn"},{"location":"first_example/#introduction","text":"The reason RSeqAn was created was to allow for easy integration of the SeqAn biological sequence analysis C++ library into R packages. While R is an excellent language for many other applications, it is just not fast enough for reading and writing files on the scale of next generation sequencing output. This is where a well-developed and mature library like SeqAn comes in. This vignette only goes through the first example in the A First Example section as found in the Getting Started section of the SeqAn docs. We have modified the function slightly to make it work here in R, and will go through how and why we did so. The purpose of using this example is to help the user get an idea of how to go between SeqAn and R. To take full advantage of SeqAn though the user will need to read through SeqAn's documentation. Besides that, the user is expected to have some experience with both C++ and Rcpp, although it not need be extensive. After all, that is what RSeqAn is for.","title":"Introduction"},{"location":"first_example/#template-functions-and-template-classes","text":"The simple example in pattern_search does, as you might expect, a pattern search of a short query sequence (pattern) in a long subject sequence. It returns an integer score value for each position of the database sequence (text) as the sum of matching characters between the pattern string and the subject substring of the database sequence. // [[Rcpp::depends(RSeqAn)]] #include <iostream> #include <seqan/file.h> #include <seqan/sequence.h> #include <Rcpp.h> using namespace Rcpp ; using namespace seqan ; // [[Rcpp::export]] IntegerVector pattern_search ( std :: string t , std :: string p ) { seqan :: String < char > text = t ; seqan :: String < char > pattern = p ; seqan :: String < int > score ; resize ( score , length ( text ) - length ( pattern ) + 1 ); // Computation of the similarities // Iteration over the text (outer loop) for ( unsigned i = 0 ; i < length ( text ) - length ( pattern ) + 1 ; ++ i ) { int localScore = 0 ; // Iteration over the pattern for character comparison for ( unsigned j = 0 ; j < length ( pattern ); ++ j ) { if ( text [ i + j ] == pattern [ j ]) ++ localScore ; } score [ i ] = localScore ; } // Returning the result IntegerVector s ( length ( score )); for ( unsigned i = 0 ; i < length ( score ); ++ i ) s [ i ] = score [ i ]; return s ; } The results are shown below. We see that the maximum score possible is 8, as there are 8 characters in the pattern tutorial , and it achieves that maximum score when we match together tutorial in the text string and tutorial in the pattern string. As well, the first position has a score of 1, because the i in the pattern string tutorial matches the 1 i in is ; the subject substring here is This is . pattern_search ( \"This is an awesome tutorial to get to know SeqAn!\" , \"tutorial\" ) #> [1] 1 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 0 1 0 8 0 1 0 0 0 0 2 0 1 0 0 1 0 3 0 #> [36] 1 0 1 0 0 0 0","title":"Template functions and template classes"},{"location":"first_example/#a-more-detailed-look-at-the-program","text":"As we can see, writing a C++ function that utilizes SeqAn inside R is quite easy with Rcpp. We included <seqan/file.h> as well as <seqan/sequence.h> as those are the modules that provide the SeqAn String class . This is one of the most fundamental classes in SeqAn. However, the function we wrote does look slightly different from the one in the A First Example section. First, instead of the function int main() , we have instead written the function IntegerVector pattern_search(std::string t, std::string p) . (Note: we already declared the namespace std, but it was left here in the function for clarity) Next, instead of printing the score to stdout, we are returning it as an IntegerVector . The reason we did this is that in order for any function using SeqAn to be useful in R, we probably want it to return something and to take in input. This means that the input and output object types need to be translatable between R and C++. SeqAn uses its own template functions and template classes , and the String class is one of the most fundamental classes in SeqAn. This makes sense since SeqAn is all about analyzing sequences. However, the String class has no direct translation to R. If you try to input String<char> text or return String<int> score you will end up with loads of errors from the compiler. So, how do we deal with this? One way to do this is by writing conversion functions such that R and C++ both understand what the data type you are using (such as String) means. Rcpp provides a nice way to do this through Rcpp::as<T>(obj) to convert from R to C++ and Rcpp::wrap(obj) to convert from C++ to R. More of this is covered in the Rcpp vignette Extending Rcpp . Once these functions are written, this is nice for the user as they can just go ahead and Rcpp::wrap and Rcpp::as<T> as they need. This has not been implemented in RSeqAn yet though, although it is a future goal. Thus for now the user will have to pay attention to how to convert between classes in SeqAn and objects in R for each function that is written. Rcpp has its own data types for going between R and C++, and so that is the IntegerVector we declare here. Since score is essentially a vector of class String with type int , instead of iterating through score and printing to stdout, we create an IntegerVector s with the same length as score and iterate through score copying its values to s in order to be able to return the values in score . Similarly, we make use of the fact that Rcpp already autoconverts character strings in R to character strings in C++ and that character strings in C++ can be converted to String<char> in SeqAn to write pattern_search such that we can run it from R.","title":"A more detailed look at the program"},{"location":"linking/","text":"Introduction The reason RSeqAn was created was to allow for easy integration of the SeqAn biological sequence analysis C++ library into R packages. This vignette describes how to link to RSeqAn from another R package as well as how to configure RSeqAn for your own build system such as enabling zlib or bzip2 . Linking Dependencies for linking Prerequisites for linking to RSeqAn are: Compiler needs to support C++14 standard. This is the default standard from GCC6 on . You need to tell the build system to use C++14, either by modifying the SystemRequirements field of the DESCRIPTION file: SystemRequirements: C++14 or (preferred) by specifying it in src/Makevars : CXX_STD = CXX14 Rcpp needs to be installed and imported inside the DESCRIPTION file: Imports: Rcpp as well as specified in the NAMESPACE file: importFrom(Rcpp, sourceCpp) Note: If you generate your NAMESPACE with roxygen2 then don't worry about the NAMESPACE file. Linking to RSeqAn As long as the prerequisites are satisfied, then linking to RSeqAn is simple. Just put RSeqAn into the Imports field of the DESCRIPTION file as well, and then put LinkingTo : Rcpp , RSeqAn also in the DESCRIPTION file. In C or C++ code, use #include <seqan/$filename.h> as usual, as well as // [[Rcpp::depends(RSeqAn)]] as usual . For an example, you can look at the qckitfastq package source code . Configuring RSeqAn By default SeqAn and thus RSeqAn are not set up to make use of libraries like zlib and bzip2 although it has the capabilities. In order to enable and set options for these libraries (assuming the libraries are installed), preprocessor flags for it should be set in src/Makevars (preferred) or using Sys.setenv() . As an example for enabling zlib : In src/Makevars , write: PKG_CXXFLAGS=-DSEQAN_HAS_ZLIB Using Sys.setenv() : Sys.setenv(\"PKG_CXXFLAGS\"=\"-DSEQAN_HAS_ZLIB\") You can see other preprocessor defines that can be set at the SeqAn documentation . Example script An example script using Sys.setenv() to set preprocessor defines that follows the SeqAn SAM and BAM I/O tutorial is below: Sys.setenv ( \"PKG_CXXFLAGS\" = \"-DSEQAN_HAS_ZLIB -std=c++14\" ) // [[Rcpp::depends(RSeqAn)]] #include <seqan/bam_io.h> #include <Rcpp.h> using namespace Rcpp ; // [[Rcpp::export]] int readBam () { // test.bam is in vignettes folder seqan :: CharString bamFileName = \"toy.bam\" ; // Open input file, BamFileIn can read SAM and BAM files. seqan :: BamFileIn bamFileIn ( toCString ( bamFileName )); // Open output file, BamFileOut accepts also an ostream and a format tag. // Note the usage of Rcout instead of std::cout seqan :: BamFileOut bamFileOut ( context ( bamFileIn ), Rcout , seqan :: Sam ()); // Copy header. seqan :: BamHeader header ; seqan :: readHeader ( header , bamFileIn ); seqan :: writeHeader ( bamFileOut , header ); // Copy records. seqan :: BamAlignmentRecord record ; while ( ! atEnd ( bamFileIn )) { seqan :: readRecord ( record , bamFileIn ); seqan :: writeRecord ( bamFileOut , record ); } return 0 ; } readBam () ## @SQ SN : ref LN : 45 ## @SQ SN : ref2 LN : 40 ## r001 163 ref 7 30 8 M4I4M1D3M = 37 39 TTAGATAAAGAGGATACTG * XX : B : S , 12561 , 2 , 20 , 112 ## r002 0 ref 9 30 1 S2I6M1P1I1P1I4M2I * 0 0 AAAAGATAAGGGATAAA * ## r003 0 ref 9 30 5 H6M * 0 0 AGCTAA * SA : Z : ref , 29 , - , 6 H5M , 17 , 0 ; ## r004 0 ref 16 30 6 M14N1I5M * 0 0 ATAGCTCTCAGC * ## r003 16 ref 29 30 6 H5M * 0 0 TAGGC * SA : Z : ref , 9 , + , 5 S6M , 30 , 1 ; ## r001 83 ref 37 30 9 M = 7 - 39 CAGCGCCAT * NM : i : 1 ## r005 4 * 0 0 8 X * 0 8 AAAAAAAA * ## [ 1 ] 0","title":"Linking to and configuring RSeqAn"},{"location":"linking/#introduction","text":"The reason RSeqAn was created was to allow for easy integration of the SeqAn biological sequence analysis C++ library into R packages. This vignette describes how to link to RSeqAn from another R package as well as how to configure RSeqAn for your own build system such as enabling zlib or bzip2 .","title":"Introduction"},{"location":"linking/#linking","text":"","title":"Linking"},{"location":"linking/#dependencies-for-linking","text":"Prerequisites for linking to RSeqAn are: Compiler needs to support C++14 standard. This is the default standard from GCC6 on . You need to tell the build system to use C++14, either by modifying the SystemRequirements field of the DESCRIPTION file: SystemRequirements: C++14 or (preferred) by specifying it in src/Makevars : CXX_STD = CXX14 Rcpp needs to be installed and imported inside the DESCRIPTION file: Imports: Rcpp as well as specified in the NAMESPACE file: importFrom(Rcpp, sourceCpp) Note: If you generate your NAMESPACE with roxygen2 then don't worry about the NAMESPACE file.","title":"Dependencies for linking"},{"location":"linking/#linking-to-rseqan","text":"As long as the prerequisites are satisfied, then linking to RSeqAn is simple. Just put RSeqAn into the Imports field of the DESCRIPTION file as well, and then put LinkingTo : Rcpp , RSeqAn also in the DESCRIPTION file. In C or C++ code, use #include <seqan/$filename.h> as usual, as well as // [[Rcpp::depends(RSeqAn)]] as usual . For an example, you can look at the qckitfastq package source code .","title":"Linking to RSeqAn"},{"location":"linking/#configuring-rseqan","text":"By default SeqAn and thus RSeqAn are not set up to make use of libraries like zlib and bzip2 although it has the capabilities. In order to enable and set options for these libraries (assuming the libraries are installed), preprocessor flags for it should be set in src/Makevars (preferred) or using Sys.setenv() . As an example for enabling zlib : In src/Makevars , write: PKG_CXXFLAGS=-DSEQAN_HAS_ZLIB Using Sys.setenv() : Sys.setenv(\"PKG_CXXFLAGS\"=\"-DSEQAN_HAS_ZLIB\") You can see other preprocessor defines that can be set at the SeqAn documentation .","title":"Configuring RSeqAn"},{"location":"linking/#example-script","text":"An example script using Sys.setenv() to set preprocessor defines that follows the SeqAn SAM and BAM I/O tutorial is below: Sys.setenv ( \"PKG_CXXFLAGS\" = \"-DSEQAN_HAS_ZLIB -std=c++14\" ) // [[Rcpp::depends(RSeqAn)]] #include <seqan/bam_io.h> #include <Rcpp.h> using namespace Rcpp ; // [[Rcpp::export]] int readBam () { // test.bam is in vignettes folder seqan :: CharString bamFileName = \"toy.bam\" ; // Open input file, BamFileIn can read SAM and BAM files. seqan :: BamFileIn bamFileIn ( toCString ( bamFileName )); // Open output file, BamFileOut accepts also an ostream and a format tag. // Note the usage of Rcout instead of std::cout seqan :: BamFileOut bamFileOut ( context ( bamFileIn ), Rcout , seqan :: Sam ()); // Copy header. seqan :: BamHeader header ; seqan :: readHeader ( header , bamFileIn ); seqan :: writeHeader ( bamFileOut , header ); // Copy records. seqan :: BamAlignmentRecord record ; while ( ! atEnd ( bamFileIn )) { seqan :: readRecord ( record , bamFileIn ); seqan :: writeRecord ( bamFileOut , record ); } return 0 ; } readBam () ## @SQ SN : ref LN : 45 ## @SQ SN : ref2 LN : 40 ## r001 163 ref 7 30 8 M4I4M1D3M = 37 39 TTAGATAAAGAGGATACTG * XX : B : S , 12561 , 2 , 20 , 112 ## r002 0 ref 9 30 1 S2I6M1P1I1P1I4M2I * 0 0 AAAAGATAAGGGATAAA * ## r003 0 ref 9 30 5 H6M * 0 0 AGCTAA * SA : Z : ref , 29 , - , 6 H5M , 17 , 0 ; ## r004 0 ref 16 30 6 M14N1I5M * 0 0 ATAGCTCTCAGC * ## r003 16 ref 29 30 6 H5M * 0 0 TAGGC * SA : Z : ref , 9 , + , 5 S6M , 30 , 1 ; ## r001 83 ref 37 30 9 M = 7 - 39 CAGCGCCAT * NM : i : 1 ## r005 4 * 0 0 8 X * 0 8 AAAAAAAA * ## [ 1 ] 0","title":"Example script"}]}